# 程序分析那些事--JavaParser

JavaParser一个将Java源码转换成抽象语法树的类库，基于抽象语法书，可以以简单的函数编程方法处理Java代码；支持Java 1- 14 特性；



### JavaParser功能

主要包含以下几个方面：

+ 将java源代码转化成AST抽象语法树
+ 解析AST抽象语法树节点的符号
  + 解析表达式的类型；比如表达式`1+2`，通过`expression.calculateResolvedType()`方法得到出其类型为int
  + 解析类型的full type；比如`A a`，通过`node.resolve().getType()`方法得到其类型为`myexample.A`
  + 解析方法的签名（signature）；比如`System.out.print(0)`，通过`methodDeclaration.getQualifiedSignature`方法得到其方法签名为`java.io.PrintStream.print(int)`
+ 可以将AST抽象语法树输出到不同的文件格式：json格式、xml格式、yaml格式、Graphviz格式
+ 将AST抽象语法树转化成Java源代码



### 示例

将源代码解析成AST语法树

~~~java
package com;

public class Calculator {
    // to get the sum of two number x, y
    int sum(int x, int y){
        int z = x + y;

        return z;
    }
}
~~~

输入Calculator的路径，通过调用parseFile(String)方法生成一个编译单元，并打印一个Yaml格式的AST

~~~java
public static ParseResult<CompilationUnit> parseFile(String pathName) throws Exception {
  try (InputStream stream = new FileInputStream(new File(pathName))) {
    JavaParser parser = new JavaParser();
    ParseResult<CompilationUnit> parseResult = parser.parse(stream);

    if (parseResult.isSuccessful()) {
      YamlPrinter printer = new YamlPrinter(true);
      System.out.println(printer.output(parseResult.getResult().get()));
    } else {
      System.out.println("error");
    }

    return parseResult;
  }
}
~~~

其抽象语法树的SVG图如下：

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="1064pt" height="526pt"
 viewBox="0.00 0.00 2138.27 1052.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 1048)">
<title>%3</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-1048 2134.2715,-1048 2134.2715,4 -4,4"/>
<!-- n0 -->
<g id="node1" class="node">
<title>n0</title>
<ellipse fill="none" stroke="#000000" cx="775.3684" cy="-1026" rx="92.2851" ry="18"/>
<text text-anchor="middle" x="775.3684" y="-1021.8" font-family="Times,serif" font-size="14.00" fill="#000000">root (CompilationUnit)</text>
</g>
<!-- n1 -->
<g id="node2" class="node">
<title>n1</title>
<ellipse fill="none" stroke="#000000" cx="672.3684" cy="-954" rx="159.2576" ry="18"/>
<text text-anchor="middle" x="672.3684" y="-949.8" font-family="Times,serif" font-size="14.00" fill="#000000">packageDeclaration (PackageDeclaration)</text>
</g>
<!-- n0&#45;&gt;n1 -->
<g id="edge1" class="edge">
<title>n0&#45;&gt;n1</title>
<path fill="none" stroke="#000000" d="M750.435,-1008.5708C737.0967,-999.247 720.4845,-987.6345 706.0171,-977.5214"/>
<polygon fill="#000000" stroke="#000000" points="707.9891,-974.6296 697.7878,-971.7689 703.9786,-980.3668 707.9891,-974.6296"/>
</g>
<!-- n4 -->
<g id="node5" class="node">
<title>n4</title>
<ellipse fill="none" stroke="#000000" cx="879.3684" cy="-954" rx="28.5497" ry="18"/>
<text text-anchor="middle" x="879.3684" y="-949.8" font-family="Times,serif" font-size="14.00" fill="#000000">types</text>
</g>
<!-- n0&#45;&gt;n4 -->
<g id="edge4" class="edge">
<title>n0&#45;&gt;n4</title>
<path fill="none" stroke="#000000" d="M800.5439,-1008.5708C815.9635,-997.8957 835.7166,-984.2205 851.5912,-973.2304"/>
<polygon fill="#000000" stroke="#000000" points="853.7296,-976.0069 859.9593,-967.4371 849.7451,-970.2516 853.7296,-976.0069"/>
</g>
<!-- n2 -->
<g id="node3" class="node">
<title>n2</title>
<ellipse fill="none" stroke="#000000" cx="670.3684" cy="-882" rx="58.4477" ry="18"/>
<text text-anchor="middle" x="670.3684" y="-877.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (Name)</text>
</g>
<!-- n1&#45;&gt;n2 -->
<g id="edge2" class="edge">
<title>n1&#45;&gt;n2</title>
<path fill="none" stroke="#000000" d="M671.8637,-935.8314C671.6498,-928.131 671.3955,-918.9743 671.1578,-910.4166"/>
<polygon fill="#000000" stroke="#000000" points="674.6563,-910.3122 670.8799,-900.4133 667.659,-910.5066 674.6563,-910.3122"/>
</g>
<!-- n3 -->
<g id="node4" class="node">
<title>n3</title>
<ellipse fill="none" stroke="#000000" cx="610.3684" cy="-810" rx="65.3693" ry="18"/>
<text text-anchor="middle" x="610.3684" y="-805.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;com&#39;</text>
</g>
<!-- n2&#45;&gt;n3 -->
<g id="edge3" class="edge">
<title>n2&#45;&gt;n3</title>
<path fill="none" stroke="#000000" d="M655.5369,-864.2022C648.2711,-855.4832 639.3943,-844.8311 631.4392,-835.2849"/>
<polygon fill="#000000" stroke="#000000" points="634.1199,-833.0346 625.0293,-827.593 628.7424,-837.5159 634.1199,-833.0346"/>
</g>
<!-- n5 -->
<g id="node6" class="node">
<title>n5</title>
<ellipse fill="none" stroke="#000000" cx="940.3684" cy="-882" rx="134.678" ry="18"/>
<text text-anchor="middle" x="940.3684" y="-877.8" font-family="Times,serif" font-size="14.00" fill="#000000">type (ClassOrInterfaceDeclaration)</text>
</g>
<!-- n4&#45;&gt;n5 -->
<g id="edge5" class="edge">
<title>n4&#45;&gt;n5</title>
<path fill="none" stroke="#000000" d="M892.9063,-938.0209C900.4396,-929.1291 909.9972,-917.848 918.5581,-907.7433"/>
<polygon fill="#000000" stroke="#000000" points="921.3588,-909.8521 925.1525,-899.9597 916.0179,-905.3271 921.3588,-909.8521"/>
</g>
<!-- n6 -->
<g id="node7" class="node">
<title>n6</title>
<ellipse fill="none" stroke="#000000" cx="766.3684" cy="-810" rx="72.0755" ry="18"/>
<text text-anchor="middle" x="766.3684" y="-805.8" font-family="Times,serif" font-size="14.00" fill="#000000">isInterface=&#39;false&#39;</text>
</g>
<!-- n5&#45;&gt;n6 -->
<g id="edge6" class="edge">
<title>n5&#45;&gt;n6</title>
<path fill="none" stroke="#000000" d="M898.6911,-864.7542C872.9922,-854.1202 839.9732,-840.4571 813.3481,-829.4399"/>
<polygon fill="#000000" stroke="#000000" points="814.432,-826.1006 803.8536,-825.5111 811.7555,-832.5688 814.432,-826.1006"/>
</g>
<!-- n7 -->
<g id="node8" class="node">
<title>n7</title>
<ellipse fill="none" stroke="#000000" cx="940.3684" cy="-810" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="940.3684" y="-805.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n5&#45;&gt;n7 -->
<g id="edge7" class="edge">
<title>n5&#45;&gt;n7</title>
<path fill="none" stroke="#000000" d="M940.3684,-863.8314C940.3684,-856.131 940.3684,-846.9743 940.3684,-838.4166"/>
<polygon fill="#000000" stroke="#000000" points="943.8685,-838.4132 940.3684,-828.4133 936.8685,-838.4133 943.8685,-838.4132"/>
</g>
<!-- n9 -->
<g id="node10" class="node">
<title>n9</title>
<ellipse fill="none" stroke="#000000" cx="1084.3684" cy="-810" rx="42.5456" ry="18"/>
<text text-anchor="middle" x="1084.3684" y="-805.8" font-family="Times,serif" font-size="14.00" fill="#000000">members</text>
</g>
<!-- n5&#45;&gt;n9 -->
<g id="edge9" class="edge">
<title>n5&#45;&gt;n9</title>
<path fill="none" stroke="#000000" d="M975.2268,-864.5708C997.0764,-853.646 1025.2102,-839.5791 1047.4412,-828.4636"/>
<polygon fill="#000000" stroke="#000000" points="1049.1928,-831.501 1056.5718,-823.8983 1046.0622,-825.24 1049.1928,-831.501"/>
</g>
<!-- n52 -->
<g id="node53" class="node">
<title>n52</title>
<ellipse fill="none" stroke="#000000" cx="1331.3684" cy="-810" rx="43.5319" ry="18"/>
<text text-anchor="middle" x="1331.3684" y="-805.8" font-family="Times,serif" font-size="14.00" fill="#000000">modifiers</text>
</g>
<!-- n5&#45;&gt;n52 -->
<g id="edge52" class="edge">
<title>n5&#45;&gt;n52</title>
<path fill="none" stroke="#000000" d="M1019.4931,-867.4297C1097.7589,-853.0176 1215.1489,-831.401 1281.3327,-819.2137"/>
<polygon fill="#000000" stroke="#000000" points="1282.3006,-822.5944 1291.5013,-817.3413 1281.0328,-815.7102 1282.3006,-822.5944"/>
</g>
<!-- n8 -->
<g id="node9" class="node">
<title>n8</title>
<ellipse fill="none" stroke="#000000" cx="863.3684" cy="-738" rx="87.0848" ry="18"/>
<text text-anchor="middle" x="863.3684" y="-733.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;Calculator&#39;</text>
</g>
<!-- n7&#45;&gt;n8 -->
<g id="edge8" class="edge">
<title>n7&#45;&gt;n8</title>
<path fill="none" stroke="#000000" d="M921.3347,-792.2022C911.7304,-783.2217 899.9329,-772.1902 889.4937,-762.4289"/>
<polygon fill="#000000" stroke="#000000" points="891.8779,-759.8665 882.1832,-755.593 887.097,-764.9795 891.8779,-759.8665"/>
</g>
<!-- n10 -->
<g id="node11" class="node">
<title>n10</title>
<ellipse fill="none" stroke="#000000" cx="1084.3684" cy="-738" rx="115.8782" ry="18"/>
<text text-anchor="middle" x="1084.3684" y="-733.8" font-family="Times,serif" font-size="14.00" fill="#000000">member (MethodDeclaration)</text>
</g>
<!-- n9&#45;&gt;n10 -->
<g id="edge10" class="edge">
<title>n9&#45;&gt;n10</title>
<path fill="none" stroke="#000000" d="M1084.3684,-791.8314C1084.3684,-784.131 1084.3684,-774.9743 1084.3684,-766.4166"/>
<polygon fill="#000000" stroke="#000000" points="1087.8685,-766.4132 1084.3684,-756.4133 1080.8685,-766.4133 1087.8685,-766.4132"/>
</g>
<!-- n11 -->
<g id="node12" class="node">
<title>n11</title>
<ellipse fill="none" stroke="#000000" cx="634.3684" cy="-666" rx="73.9601" ry="18"/>
<text text-anchor="middle" x="634.3684" y="-661.8" font-family="Times,serif" font-size="14.00" fill="#000000">body (BlockStmt)</text>
</g>
<!-- n10&#45;&gt;n11 -->
<g id="edge11" class="edge">
<title>n10&#45;&gt;n11</title>
<path fill="none" stroke="#000000" d="M999.3211,-725.6339C895.2693,-710.4826 731.13,-686.5017 717.3684,-684 711.2755,-682.8924 704.9478,-681.6637 698.6262,-680.3835"/>
<polygon fill="#000000" stroke="#000000" points="699.2335,-676.9351 688.7322,-678.3393 697.8172,-683.7903 699.2335,-676.9351"/>
</g>
<!-- n33 -->
<g id="node34" class="node">
<title>n33</title>
<ellipse fill="none" stroke="#000000" cx="810.3684" cy="-666" rx="83.8064" ry="18"/>
<text text-anchor="middle" x="810.3684" y="-661.8" font-family="Times,serif" font-size="14.00" fill="#000000">type (PrimitiveType)</text>
</g>
<!-- n10&#45;&gt;n33 -->
<g id="edge33" class="edge">
<title>n10&#45;&gt;n33</title>
<path fill="none" stroke="#000000" d="M1025.2518,-722.4657C980.5489,-710.719 919.2796,-694.619 873.6006,-682.6158"/>
<polygon fill="#000000" stroke="#000000" points="874.3712,-679.1995 863.81,-680.043 872.5921,-685.9697 874.3712,-679.1995"/>
</g>
<!-- n35 -->
<g id="node36" class="node">
<title>n35</title>
<ellipse fill="none" stroke="#000000" cx="995.3684" cy="-666" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="995.3684" y="-661.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n10&#45;&gt;n35 -->
<g id="edge35" class="edge">
<title>n10&#45;&gt;n35</title>
<path fill="none" stroke="#000000" d="M1062.3684,-720.2022C1051.1596,-711.1345 1037.3663,-699.9758 1025.2142,-690.1449"/>
<polygon fill="#000000" stroke="#000000" points="1027.0912,-687.1615 1017.1153,-683.593 1022.6885,-692.6036 1027.0912,-687.1615"/>
</g>
<!-- n37 -->
<g id="node38" class="node">
<title>n37</title>
<ellipse fill="none" stroke="#000000" cx="1199.3684" cy="-666" rx="102.4069" ry="18"/>
<text text-anchor="middle" x="1199.3684" y="-661.8" font-family="Times,serif" font-size="14.00" fill="#000000">comment (LineComment)</text>
</g>
<!-- n10&#45;&gt;n37 -->
<g id="edge37" class="edge">
<title>n10&#45;&gt;n37</title>
<path fill="none" stroke="#000000" d="M1112.5006,-720.3868C1127.649,-710.9026 1146.5148,-699.0909 1162.7909,-688.9007"/>
<polygon fill="#000000" stroke="#000000" points="1164.9082,-691.7046 1171.5267,-683.4313 1161.1935,-685.7715 1164.9082,-691.7046"/>
</g>
<!-- n39 -->
<g id="node40" class="node">
<title>n39</title>
<ellipse fill="none" stroke="#000000" cx="1416.3684" cy="-666" rx="48.7928" ry="18"/>
<text text-anchor="middle" x="1416.3684" y="-661.8" font-family="Times,serif" font-size="14.00" fill="#000000">parameters</text>
</g>
<!-- n10&#45;&gt;n39 -->
<g id="edge39" class="edge">
<title>n10&#45;&gt;n39</title>
<path fill="none" stroke="#000000" d="M1151.9537,-723.3429C1214.7318,-709.7284 1306.9001,-689.7401 1364.1879,-677.3163"/>
<polygon fill="#000000" stroke="#000000" points="1365.0847,-680.7032 1374.1157,-675.1632 1363.601,-673.8622 1365.0847,-680.7032"/>
</g>
<!-- n12 -->
<g id="node13" class="node">
<title>n12</title>
<ellipse fill="none" stroke="#000000" cx="634.3684" cy="-594" rx="47.3736" ry="18"/>
<text text-anchor="middle" x="634.3684" y="-589.8" font-family="Times,serif" font-size="14.00" fill="#000000">statements</text>
</g>
<!-- n11&#45;&gt;n12 -->
<g id="edge12" class="edge">
<title>n11&#45;&gt;n12</title>
<path fill="none" stroke="#000000" d="M634.3684,-647.8314C634.3684,-640.131 634.3684,-630.9743 634.3684,-622.4166"/>
<polygon fill="#000000" stroke="#000000" points="637.8685,-622.4132 634.3684,-612.4133 630.8685,-622.4133 637.8685,-622.4132"/>
</g>
<!-- n13 -->
<g id="node14" class="node">
<title>n13</title>
<ellipse fill="none" stroke="#000000" cx="515.3684" cy="-522" rx="108.2122" ry="18"/>
<text text-anchor="middle" x="515.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">statement (ExpressionStmt)</text>
</g>
<!-- n12&#45;&gt;n13 -->
<g id="edge13" class="edge">
<title>n12&#45;&gt;n13</title>
<path fill="none" stroke="#000000" d="M609.1316,-578.7307C592.8321,-568.8688 571.3288,-555.8584 553.027,-544.785"/>
<polygon fill="#000000" stroke="#000000" points="554.7041,-541.709 544.3364,-539.5269 551.0804,-547.6981 554.7041,-541.709"/>
</g>
<!-- n29 -->
<g id="node30" class="node">
<title>n29</title>
<ellipse fill="none" stroke="#000000" cx="744.3684" cy="-522" rx="92.7524" ry="18"/>
<text text-anchor="middle" x="744.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">statement (ReturnStmt)</text>
</g>
<!-- n12&#45;&gt;n29 -->
<g id="edge29" class="edge">
<title>n12&#45;&gt;n29</title>
<path fill="none" stroke="#000000" d="M658.2368,-578.3771C673.1954,-568.586 692.735,-555.7964 709.4214,-544.8744"/>
<polygon fill="#000000" stroke="#000000" points="711.3976,-547.764 717.8478,-539.3589 707.564,-541.9071 711.3976,-547.764"/>
</g>
<!-- n14 -->
<g id="node15" class="node">
<title>n14</title>
<ellipse fill="none" stroke="#000000" cx="497.3684" cy="-450" rx="143.8581" ry="18"/>
<text text-anchor="middle" x="497.3684" y="-445.8" font-family="Times,serif" font-size="14.00" fill="#000000">expression (VariableDeclarationExpr)</text>
</g>
<!-- n13&#45;&gt;n14 -->
<g id="edge14" class="edge">
<title>n13&#45;&gt;n14</title>
<path fill="none" stroke="#000000" d="M510.8262,-503.8314C508.88,-496.0463 506.5616,-486.7729 504.4021,-478.1347"/>
<polygon fill="#000000" stroke="#000000" points="507.7927,-477.2658 501.9717,-468.4133 501.0017,-478.9636 507.7927,-477.2658"/>
</g>
<!-- n15 -->
<g id="node16" class="node">
<title>n15</title>
<ellipse fill="none" stroke="#000000" cx="497.3684" cy="-378" rx="42.0524" ry="18"/>
<text text-anchor="middle" x="497.3684" y="-373.8" font-family="Times,serif" font-size="14.00" fill="#000000">variables</text>
</g>
<!-- n14&#45;&gt;n15 -->
<g id="edge15" class="edge">
<title>n14&#45;&gt;n15</title>
<path fill="none" stroke="#000000" d="M497.3684,-431.8314C497.3684,-424.131 497.3684,-414.9743 497.3684,-406.4166"/>
<polygon fill="#000000" stroke="#000000" points="500.8685,-406.4132 497.3684,-396.4133 493.8685,-406.4133 500.8685,-406.4132"/>
</g>
<!-- n16 -->
<g id="node17" class="node">
<title>n16</title>
<ellipse fill="none" stroke="#000000" cx="497.3684" cy="-306" rx="113.421" ry="18"/>
<text text-anchor="middle" x="497.3684" y="-301.8" font-family="Times,serif" font-size="14.00" fill="#000000">variable (VariableDeclarator)</text>
</g>
<!-- n15&#45;&gt;n16 -->
<g id="edge16" class="edge">
<title>n15&#45;&gt;n16</title>
<path fill="none" stroke="#000000" d="M497.3684,-359.8314C497.3684,-352.131 497.3684,-342.9743 497.3684,-334.4166"/>
<polygon fill="#000000" stroke="#000000" points="500.8685,-334.4132 497.3684,-324.4133 493.8685,-334.4133 500.8685,-334.4132"/>
</g>
<!-- n17 -->
<g id="node18" class="node">
<title>n17</title>
<ellipse fill="none" stroke="#000000" cx="264.3684" cy="-234" rx="93.2025" ry="18"/>
<text text-anchor="middle" x="264.3684" y="-229.8" font-family="Times,serif" font-size="14.00" fill="#000000">initializer (BinaryExpr)</text>
</g>
<!-- n16&#45;&gt;n17 -->
<g id="edge17" class="edge">
<title>n16&#45;&gt;n17</title>
<path fill="none" stroke="#000000" d="M445.3687,-289.9314C409.2946,-278.7841 361.1721,-263.9136 323.6149,-252.3079"/>
<polygon fill="#000000" stroke="#000000" points="324.4033,-248.8883 313.8157,-249.2798 322.3366,-255.5763 324.4033,-248.8883"/>
</g>
<!-- n25 -->
<g id="node26" class="node">
<title>n25</title>
<ellipse fill="none" stroke="#000000" cx="497.3684" cy="-234" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="497.3684" y="-229.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n16&#45;&gt;n25 -->
<g id="edge25" class="edge">
<title>n16&#45;&gt;n25</title>
<path fill="none" stroke="#000000" d="M497.3684,-287.8314C497.3684,-280.131 497.3684,-270.9743 497.3684,-262.4166"/>
<polygon fill="#000000" stroke="#000000" points="500.8685,-262.4132 497.3684,-252.4133 493.8685,-262.4133 500.8685,-262.4132"/>
</g>
<!-- n27 -->
<g id="node28" class="node">
<title>n27</title>
<ellipse fill="none" stroke="#000000" cx="682.3684" cy="-234" rx="83.8064" ry="18"/>
<text text-anchor="middle" x="682.3684" y="-229.8" font-family="Times,serif" font-size="14.00" fill="#000000">type (PrimitiveType)</text>
</g>
<!-- n16&#45;&gt;n27 -->
<g id="edge27" class="edge">
<title>n16&#45;&gt;n27</title>
<path fill="none" stroke="#000000" d="M540.2761,-289.3008C567.7033,-278.6264 603.3893,-264.7378 632.1365,-253.5497"/>
<polygon fill="#000000" stroke="#000000" points="633.548,-256.7562 641.5976,-249.8675 631.0091,-250.2328 633.548,-256.7562"/>
</g>
<!-- n18 -->
<g id="node19" class="node">
<title>n18</title>
<ellipse fill="none" stroke="#000000" cx="69.3684" cy="-162" rx="69.2371" ry="18"/>
<text text-anchor="middle" x="69.3684" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">operator=&#39;PLUS&#39;</text>
</g>
<!-- n17&#45;&gt;n18 -->
<g id="edge18" class="edge">
<title>n17&#45;&gt;n18</title>
<path fill="none" stroke="#000000" d="M221.0916,-218.0209C190.8911,-206.8699 150.5135,-191.9613 119.0051,-180.3274"/>
<polygon fill="#000000" stroke="#000000" points="120.1257,-177.0102 109.5324,-176.8298 117.701,-183.5769 120.1257,-177.0102"/>
</g>
<!-- n19 -->
<g id="node20" class="node">
<title>n19</title>
<ellipse fill="none" stroke="#000000" cx="225.3684" cy="-162" rx="68.0956" ry="18"/>
<text text-anchor="middle" x="225.3684" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">left (NameExpr)</text>
</g>
<!-- n17&#45;&gt;n19 -->
<g id="edge19" class="edge">
<title>n17&#45;&gt;n19</title>
<path fill="none" stroke="#000000" d="M254.5271,-215.8314C250.1057,-207.6688 244.798,-197.87 239.9299,-188.8827"/>
<polygon fill="#000000" stroke="#000000" points="242.9119,-187.0393 235.0715,-179.9134 236.7569,-190.3734 242.9119,-187.0393"/>
</g>
<!-- n22 -->
<g id="node23" class="node">
<title>n22</title>
<ellipse fill="none" stroke="#000000" cx="385.3684" cy="-162" rx="73.4323" ry="18"/>
<text text-anchor="middle" x="385.3684" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">right (NameExpr)</text>
</g>
<!-- n17&#45;&gt;n22 -->
<g id="edge22" class="edge">
<title>n17&#45;&gt;n22</title>
<path fill="none" stroke="#000000" d="M293.3509,-216.7542C309.7833,-206.9763 330.5194,-194.6374 348.1454,-184.1492"/>
<polygon fill="#000000" stroke="#000000" points="350.236,-186.9781 357.0399,-178.8566 346.6564,-180.9625 350.236,-186.9781"/>
</g>
<!-- n20 -->
<g id="node21" class="node">
<title>n20</title>
<ellipse fill="none" stroke="#000000" cx="212.3684" cy="-90" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="212.3684" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n19&#45;&gt;n20 -->
<g id="edge20" class="edge">
<title>n19&#45;&gt;n20</title>
<path fill="none" stroke="#000000" d="M222.088,-143.8314C220.6976,-136.131 219.0443,-126.9743 217.4992,-118.4166"/>
<polygon fill="#000000" stroke="#000000" points="220.9142,-117.6322 215.693,-108.4133 214.0256,-118.8761 220.9142,-117.6322"/>
</g>
<!-- n21 -->
<g id="node22" class="node">
<title>n21</title>
<ellipse fill="none" stroke="#000000" cx="212.3684" cy="-18" rx="54.7618" ry="18"/>
<text text-anchor="middle" x="212.3684" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;x&#39;</text>
</g>
<!-- n20&#45;&gt;n21 -->
<g id="edge21" class="edge">
<title>n20&#45;&gt;n21</title>
<path fill="none" stroke="#000000" d="M212.3684,-71.8314C212.3684,-64.131 212.3684,-54.9743 212.3684,-46.4166"/>
<polygon fill="#000000" stroke="#000000" points="215.8685,-46.4132 212.3684,-36.4133 208.8685,-46.4133 215.8685,-46.4132"/>
</g>
<!-- n23 -->
<g id="node24" class="node">
<title>n23</title>
<ellipse fill="none" stroke="#000000" cx="397.3684" cy="-90" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="397.3684" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n22&#45;&gt;n23 -->
<g id="edge23" class="edge">
<title>n22&#45;&gt;n23</title>
<path fill="none" stroke="#000000" d="M388.3965,-143.8314C389.6799,-136.131 391.206,-126.9743 392.6323,-118.4166"/>
<polygon fill="#000000" stroke="#000000" points="396.1078,-118.8526 394.2995,-108.4133 389.2031,-117.7018 396.1078,-118.8526"/>
</g>
<!-- n24 -->
<g id="node25" class="node">
<title>n24</title>
<ellipse fill="none" stroke="#000000" cx="397.3684" cy="-18" rx="54.7618" ry="18"/>
<text text-anchor="middle" x="397.3684" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;y&#39;</text>
</g>
<!-- n23&#45;&gt;n24 -->
<g id="edge24" class="edge">
<title>n23&#45;&gt;n24</title>
<path fill="none" stroke="#000000" d="M397.3684,-71.8314C397.3684,-64.131 397.3684,-54.9743 397.3684,-46.4166"/>
<polygon fill="#000000" stroke="#000000" points="400.8685,-46.4132 397.3684,-36.4133 393.8685,-46.4133 400.8685,-46.4132"/>
</g>
<!-- n26 -->
<g id="node27" class="node">
<title>n26</title>
<ellipse fill="none" stroke="#000000" cx="530.3684" cy="-162" rx="54.2686" ry="18"/>
<text text-anchor="middle" x="530.3684" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;z&#39;</text>
</g>
<!-- n25&#45;&gt;n26 -->
<g id="edge26" class="edge">
<title>n25&#45;&gt;n26</title>
<path fill="none" stroke="#000000" d="M505.6957,-215.8314C509.3975,-207.7547 513.8335,-198.0761 517.917,-189.1668"/>
<polygon fill="#000000" stroke="#000000" points="521.1732,-190.4624 522.1581,-179.9134 514.8098,-187.5458 521.1732,-190.4624"/>
</g>
<!-- n28 -->
<g id="node29" class="node">
<title>n28</title>
<ellipse fill="none" stroke="#000000" cx="682.3684" cy="-162" rx="48.4811" ry="18"/>
<text text-anchor="middle" x="682.3684" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">type=&#39;INT&#39;</text>
</g>
<!-- n27&#45;&gt;n28 -->
<g id="edge28" class="edge">
<title>n27&#45;&gt;n28</title>
<path fill="none" stroke="#000000" d="M682.3684,-215.8314C682.3684,-208.131 682.3684,-198.9743 682.3684,-190.4166"/>
<polygon fill="#000000" stroke="#000000" points="685.8685,-190.4132 682.3684,-180.4133 678.8685,-190.4133 685.8685,-190.4132"/>
</g>
<!-- n30 -->
<g id="node31" class="node">
<title>n30</title>
<ellipse fill="none" stroke="#000000" cx="753.3684" cy="-450" rx="94.1716" ry="18"/>
<text text-anchor="middle" x="753.3684" y="-445.8" font-family="Times,serif" font-size="14.00" fill="#000000">expression (NameExpr)</text>
</g>
<!-- n29&#45;&gt;n30 -->
<g id="edge30" class="edge">
<title>n29&#45;&gt;n30</title>
<path fill="none" stroke="#000000" d="M746.6395,-503.8314C747.602,-496.131 748.7466,-486.9743 749.8163,-478.4166"/>
<polygon fill="#000000" stroke="#000000" points="753.2993,-478.7702 751.0667,-468.4133 746.3533,-477.9019 753.2993,-478.7702"/>
</g>
<!-- n31 -->
<g id="node32" class="node">
<title>n31</title>
<ellipse fill="none" stroke="#000000" cx="753.3684" cy="-378" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="753.3684" y="-373.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n30&#45;&gt;n31 -->
<g id="edge31" class="edge">
<title>n30&#45;&gt;n31</title>
<path fill="none" stroke="#000000" d="M753.3684,-431.8314C753.3684,-424.131 753.3684,-414.9743 753.3684,-406.4166"/>
<polygon fill="#000000" stroke="#000000" points="756.8685,-406.4132 753.3684,-396.4133 749.8685,-406.4133 756.8685,-406.4132"/>
</g>
<!-- n32 -->
<g id="node33" class="node">
<title>n32</title>
<ellipse fill="none" stroke="#000000" cx="753.3684" cy="-306" rx="54.2686" ry="18"/>
<text text-anchor="middle" x="753.3684" y="-301.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;z&#39;</text>
</g>
<!-- n31&#45;&gt;n32 -->
<g id="edge32" class="edge">
<title>n31&#45;&gt;n32</title>
<path fill="none" stroke="#000000" d="M753.3684,-359.8314C753.3684,-352.131 753.3684,-342.9743 753.3684,-334.4166"/>
<polygon fill="#000000" stroke="#000000" points="756.8685,-334.4132 753.3684,-324.4133 749.8685,-334.4133 756.8685,-334.4132"/>
</g>
<!-- n34 -->
<g id="node35" class="node">
<title>n34</title>
<ellipse fill="none" stroke="#000000" cx="810.3684" cy="-594" rx="48.4811" ry="18"/>
<text text-anchor="middle" x="810.3684" y="-589.8" font-family="Times,serif" font-size="14.00" fill="#000000">type=&#39;INT&#39;</text>
</g>
<!-- n33&#45;&gt;n34 -->
<g id="edge34" class="edge">
<title>n33&#45;&gt;n34</title>
<path fill="none" stroke="#000000" d="M810.3684,-647.8314C810.3684,-640.131 810.3684,-630.9743 810.3684,-622.4166"/>
<polygon fill="#000000" stroke="#000000" points="813.8685,-622.4132 810.3684,-612.4133 806.8685,-622.4133 813.8685,-622.4132"/>
</g>
<!-- n36 -->
<g id="node37" class="node">
<title>n36</title>
<ellipse fill="none" stroke="#000000" cx="945.3684" cy="-594" rx="64.902" ry="18"/>
<text text-anchor="middle" x="945.3684" y="-589.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;sum&#39;</text>
</g>
<!-- n35&#45;&gt;n36 -->
<g id="edge36" class="edge">
<title>n35&#45;&gt;n36</title>
<path fill="none" stroke="#000000" d="M982.7513,-647.8314C976.9635,-639.497 969.9911,-629.4567 963.6436,-620.3162"/>
<polygon fill="#000000" stroke="#000000" points="966.3871,-618.1307 957.8083,-611.9134 960.6375,-622.1235 966.3871,-618.1307"/>
</g>
<!-- n38 -->
<g id="node39" class="node">
<title>n38</title>
<ellipse fill="none" stroke="#000000" cx="1194.3684" cy="-594" rx="166.2741" ry="18"/>
<text text-anchor="middle" x="1194.3684" y="-589.8" font-family="Times,serif" font-size="14.00" fill="#000000">content=&#39; to get the sum of two number x, y&#39;</text>
</g>
<!-- n37&#45;&gt;n38 -->
<g id="edge38" class="edge">
<title>n37&#45;&gt;n38</title>
<path fill="none" stroke="#000000" d="M1198.1067,-647.8314C1197.5719,-640.131 1196.9361,-630.9743 1196.3418,-622.4166"/>
<polygon fill="#000000" stroke="#000000" points="1199.8316,-622.1467 1195.6471,-612.4133 1192.8484,-622.6317 1199.8316,-622.1467"/>
</g>
<!-- n40 -->
<g id="node41" class="node">
<title>n40</title>
<ellipse fill="none" stroke="#000000" cx="1468.3684" cy="-594" rx="89.3002" ry="18"/>
<text text-anchor="middle" x="1468.3684" y="-589.8" font-family="Times,serif" font-size="14.00" fill="#000000">parameter (Parameter)</text>
</g>
<!-- n39&#45;&gt;n40 -->
<g id="edge40" class="edge">
<title>n39&#45;&gt;n40</title>
<path fill="none" stroke="#000000" d="M1428.9562,-648.5708C1435.0776,-640.095 1442.565,-629.7279 1449.3631,-620.3151"/>
<polygon fill="#000000" stroke="#000000" points="1452.336,-622.1766 1455.3535,-612.0206 1446.6612,-618.0782 1452.336,-622.1766"/>
</g>
<!-- n46 -->
<g id="node47" class="node">
<title>n46</title>
<ellipse fill="none" stroke="#000000" cx="1738.3684" cy="-594" rx="89.3002" ry="18"/>
<text text-anchor="middle" x="1738.3684" y="-589.8" font-family="Times,serif" font-size="14.00" fill="#000000">parameter (Parameter)</text>
</g>
<!-- n39&#45;&gt;n46 -->
<g id="edge46" class="edge">
<title>n39&#45;&gt;n46</title>
<path fill="none" stroke="#000000" d="M1453.0305,-654.0202C1460.0769,-651.8889 1467.4243,-649.783 1474.3684,-648 1536.6254,-632.0142 1608.1,-617.633 1660.9652,-607.7388"/>
<polygon fill="#000000" stroke="#000000" points="1661.7557,-611.1518 1670.9471,-605.8824 1660.4758,-604.2698 1661.7557,-611.1518"/>
</g>
<!-- n41 -->
<g id="node42" class="node">
<title>n41</title>
<ellipse fill="none" stroke="#000000" cx="1160.3684" cy="-522" rx="70.3782" ry="18"/>
<text text-anchor="middle" x="1160.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">isVarArgs=&#39;false&#39;</text>
</g>
<!-- n40&#45;&gt;n41 -->
<g id="edge41" class="edge">
<title>n40&#45;&gt;n41</title>
<path fill="none" stroke="#000000" d="M1409.711,-580.2879C1356.0634,-567.7469 1276.9662,-549.2566 1222.3101,-536.4799"/>
<polygon fill="#000000" stroke="#000000" points="1222.9349,-533.0316 1212.4007,-534.1634 1221.3414,-539.8479 1222.9349,-533.0316"/>
</g>
<!-- n42 -->
<g id="node43" class="node">
<title>n42</title>
<ellipse fill="none" stroke="#000000" cx="1332.3684" cy="-522" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="1332.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n40&#45;&gt;n42 -->
<g id="edge42" class="edge">
<title>n40&#45;&gt;n42</title>
<path fill="none" stroke="#000000" d="M1436.4824,-577.1192C1417.5552,-567.0989 1393.3694,-554.2946 1373.0733,-543.5496"/>
<polygon fill="#000000" stroke="#000000" points="1374.5301,-540.3607 1364.0546,-538.775 1371.2549,-546.5472 1374.5301,-540.3607"/>
</g>
<!-- n44 -->
<g id="node45" class="node">
<title>n44</title>
<ellipse fill="none" stroke="#000000" cx="1517.3684" cy="-522" rx="83.8064" ry="18"/>
<text text-anchor="middle" x="1517.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">type (PrimitiveType)</text>
</g>
<!-- n40&#45;&gt;n44 -->
<g id="edge44" class="edge">
<title>n40&#45;&gt;n44</title>
<path fill="none" stroke="#000000" d="M1480.7332,-575.8314C1486.4052,-567.497 1493.2382,-557.4567 1499.4588,-548.3162"/>
<polygon fill="#000000" stroke="#000000" points="1502.4446,-550.1498 1505.1773,-539.9134 1496.6576,-546.2114 1502.4446,-550.1498"/>
</g>
<!-- n43 -->
<g id="node44" class="node">
<title>n43</title>
<ellipse fill="none" stroke="#000000" cx="1332.3684" cy="-450" rx="54.7618" ry="18"/>
<text text-anchor="middle" x="1332.3684" y="-445.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;x&#39;</text>
</g>
<!-- n42&#45;&gt;n43 -->
<g id="edge43" class="edge">
<title>n42&#45;&gt;n43</title>
<path fill="none" stroke="#000000" d="M1332.3684,-503.8314C1332.3684,-496.131 1332.3684,-486.9743 1332.3684,-478.4166"/>
<polygon fill="#000000" stroke="#000000" points="1335.8685,-478.4132 1332.3684,-468.4133 1328.8685,-478.4133 1335.8685,-478.4132"/>
</g>
<!-- n45 -->
<g id="node46" class="node">
<title>n45</title>
<ellipse fill="none" stroke="#000000" cx="1517.3684" cy="-450" rx="48.4811" ry="18"/>
<text text-anchor="middle" x="1517.3684" y="-445.8" font-family="Times,serif" font-size="14.00" fill="#000000">type=&#39;INT&#39;</text>
</g>
<!-- n44&#45;&gt;n45 -->
<g id="edge45" class="edge">
<title>n44&#45;&gt;n45</title>
<path fill="none" stroke="#000000" d="M1517.3684,-503.8314C1517.3684,-496.131 1517.3684,-486.9743 1517.3684,-478.4166"/>
<polygon fill="#000000" stroke="#000000" points="1520.8685,-478.4132 1517.3684,-468.4133 1513.8685,-478.4133 1520.8685,-478.4132"/>
</g>
<!-- n47 -->
<g id="node48" class="node">
<title>n47</title>
<ellipse fill="none" stroke="#000000" cx="1689.3684" cy="-522" rx="70.3782" ry="18"/>
<text text-anchor="middle" x="1689.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">isVarArgs=&#39;false&#39;</text>
</g>
<!-- n46&#45;&gt;n47 -->
<g id="edge47" class="edge">
<title>n46&#45;&gt;n47</title>
<path fill="none" stroke="#000000" d="M1726.0036,-575.8314C1720.3316,-567.497 1713.4987,-557.4567 1707.2781,-548.3162"/>
<polygon fill="#000000" stroke="#000000" points="1710.0793,-546.2114 1701.5595,-539.9134 1704.2923,-550.1498 1710.0793,-546.2114"/>
</g>
<!-- n48 -->
<g id="node49" class="node">
<title>n48</title>
<ellipse fill="none" stroke="#000000" cx="1861.3684" cy="-522" rx="83.5636" ry="18"/>
<text text-anchor="middle" x="1861.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">name (SimpleName)</text>
</g>
<!-- n46&#45;&gt;n48 -->
<g id="edge48" class="edge">
<title>n46&#45;&gt;n48</title>
<path fill="none" stroke="#000000" d="M1767.5177,-576.937C1784.2144,-567.1633 1805.3585,-554.7863 1823.3485,-544.2555"/>
<polygon fill="#000000" stroke="#000000" points="1825.5663,-547.0129 1832.4284,-538.9405 1822.0301,-540.9718 1825.5663,-547.0129"/>
</g>
<!-- n50 -->
<g id="node51" class="node">
<title>n50</title>
<ellipse fill="none" stroke="#000000" cx="2046.3684" cy="-522" rx="83.8064" ry="18"/>
<text text-anchor="middle" x="2046.3684" y="-517.8" font-family="Times,serif" font-size="14.00" fill="#000000">type (PrimitiveType)</text>
</g>
<!-- n46&#45;&gt;n50 -->
<g id="edge50" class="edge">
<title>n46&#45;&gt;n50</title>
<path fill="none" stroke="#000000" d="M1797.0258,-580.2879C1849.1124,-568.1118 1925.1893,-550.3276 1979.595,-537.6094"/>
<polygon fill="#000000" stroke="#000000" points="1980.5501,-540.9805 1989.4909,-535.2961 1978.9566,-534.1643 1980.5501,-540.9805"/>
</g>
<!-- n49 -->
<g id="node50" class="node">
<title>n49</title>
<ellipse fill="none" stroke="#000000" cx="1861.3684" cy="-450" rx="54.7618" ry="18"/>
<text text-anchor="middle" x="1861.3684" y="-445.8" font-family="Times,serif" font-size="14.00" fill="#000000">identifier=&#39;y&#39;</text>
</g>
<!-- n48&#45;&gt;n49 -->
<g id="edge49" class="edge">
<title>n48&#45;&gt;n49</title>
<path fill="none" stroke="#000000" d="M1861.3684,-503.8314C1861.3684,-496.131 1861.3684,-486.9743 1861.3684,-478.4166"/>
<polygon fill="#000000" stroke="#000000" points="1864.8685,-478.4132 1861.3684,-468.4133 1857.8685,-478.4133 1864.8685,-478.4132"/>
</g>
<!-- n51 -->
<g id="node52" class="node">
<title>n51</title>
<ellipse fill="none" stroke="#000000" cx="2046.3684" cy="-450" rx="48.4811" ry="18"/>
<text text-anchor="middle" x="2046.3684" y="-445.8" font-family="Times,serif" font-size="14.00" fill="#000000">type=&#39;INT&#39;</text>
</g>
<!-- n50&#45;&gt;n51 -->
<g id="edge51" class="edge">
<title>n50&#45;&gt;n51</title>
<path fill="none" stroke="#000000" d="M2046.3684,-503.8314C2046.3684,-496.131 2046.3684,-486.9743 2046.3684,-478.4166"/>
<polygon fill="#000000" stroke="#000000" points="2049.8685,-478.4132 2046.3684,-468.4133 2042.8685,-478.4133 2049.8685,-478.4132"/>
</g>
<!-- n53 -->
<g id="node54" class="node">
<title>n53</title>
<ellipse fill="none" stroke="#000000" cx="1475.3684" cy="-738" rx="79.2548" ry="18"/>
<text text-anchor="middle" x="1475.3684" y="-733.8" font-family="Times,serif" font-size="14.00" fill="#000000">modifier (Modifier)</text>
</g>
<!-- n52&#45;&gt;n53 -->
<g id="edge53" class="edge">
<title>n52&#45;&gt;n53</title>
<path fill="none" stroke="#000000" d="M1359.1331,-796.1177C1380.1288,-785.6198 1409.3183,-771.025 1433.1932,-759.0876"/>
<polygon fill="#000000" stroke="#000000" points="1435.0093,-762.0927 1442.3883,-754.49 1431.8788,-755.8317 1435.0093,-762.0927"/>
</g>
<!-- n54 -->
<g id="node55" class="node">
<title>n54</title>
<ellipse fill="none" stroke="#000000" cx="1564.3684" cy="-666" rx="80.8468" ry="18"/>
<text text-anchor="middle" x="1564.3684" y="-661.8" font-family="Times,serif" font-size="14.00" fill="#000000">keyword=&#39;PUBLIC&#39;</text>
</g>
<!-- n53&#45;&gt;n54 -->
<g id="edge54" class="edge">
<title>n53&#45;&gt;n54</title>
<path fill="none" stroke="#000000" d="M1496.9128,-720.5708C1508.3071,-711.353 1522.4664,-699.8983 1534.8662,-689.8669"/>
<polygon fill="#000000" stroke="#000000" points="1537.1407,-692.5288 1542.7139,-683.5182 1532.7381,-687.0867 1537.1407,-692.5288"/>
</g>
</g>
</svg>



### 语法分析

JavaParser的词法和AST语法是有Javacc生成的，其抽象语法树AST的节点结构如下：

~~~
Node: 所有AST节点的超类
---->Statement: 所有语句节点的超类
-------->BlockStmt: block语句
-------->ThrowStmt: throw语句
-------->LocalClassDeclarationStmt: 
-------->TryStmt: try语句
-------->AssertStmt: assert语句
-------->ExpressionStmt
-------->ContinueStmt: contine语句
-------->SwitchEntryStmt: swith case语句
-------->BreakStmt: break语句
-------->ExplicitConstructorInvocationStmt
-------->WhileStmt: while语句
-------->ForStmt: for语句
-------->LabeledStmt: label语句
-------->IfStmt: if语句
-------->SynchronizedStmt: Synchronized语句
-------->SwitchStmt: switch语句
-------->ForEachStmt: for each语句
-------->ReturnStmt: return语句
-------->DoStmt: do-while语句
-------->UnparsableStmt
-------->EmptyStmt: 空(;)语句
---->CatchClause: catch-finnaly块
---->PackageDeclaration: 包声明
---->Comment: 注释基类
-------->BlockComment: /** **/注释
-------->JavadocComment: /** */注释
-------->LineComment: //注释
---->ArrayCreationLevel
---->ReceiverParameter
---->VariableDeclarator
---->Parameter
---->BodyDeclaration
---->SimpleName
---->Expression: 所有表达式的超类
-------->AnnotationExpr: 注解表达式
------------>NormalAnnotationExpr
------------>MarkerAnnotationExpr
------------>SingleMemberAnnotationExpr
-------->SuperExpr: super表达式
-------->LambdaExpr: lambda表达式
-------->EnclosedExpr
-------->InstanceOfExpr: instanceof表达式
-------->ArrayAccessExpr: 数组访问表达式
-------->TypeExpr: 类型表达式
-------->ObjectCreationExpr: 对象创建表达式
-------->NameExpr
-------->MethodReferenceExpr: 方法引用表达式
-------->ClassExpr: 类表达式
-------->AssignExpr: 赋值表达式
-------->LiteralExpr: 常量表达式
------------>NullLiteralExpr
------------>LiteralStringValueExpr
---------------->CharLiteralExpr
---------------->StringLiteralExpr
---------------->LongLiteralExpr
---------------->DoubleLiteralExpr
---------------->IntegerLiteralExpr
------------>BooleanLiteralExpr
-------->FieldAccessExpr: 成员变量访问
-------->ArrayInitializerExpr: 数组初始化
-------->CastExpr: cast表达式
-------->UnaryExpr: 二元表达式
-------->MethodCallExpr: 方法调用表达
-------->ThisExpr: this表达式
-------->ArrayCreationExpr: 数组创建表达式
-------->VariableDeclarationExpr: 变量声明表达式
-------->ConditionalExpr: 条件表达式
-------->BinaryExpr: 一元表达式
---->MemberValuePair
---->Name
---->ImportDeclaration: import声明
---->Type: 所有类型的超类
-------->VoidType: void类型
-------->PrimitiveType: 值类型
-------->UnknownType: 未知类型
-------->IntersectionType: Intersection类型，用于casts or while expressing bounds for generic types
-------->ReferenceType: 引用类型
------------>ClassOrInterfaceType: class或者接口类型
------------>TypeParameter: 类型参数
------------>ArrayType: 数组类型
-------->UnionType: 组合类型，用于(IOException | NullPointerException e)
-------->WildcardType: Wildcard类型
-------->VarType: var类型
---->CompilationUnit: 编译单元
---->ModuleDeclaration: module声明
---->ModuleDirective: module指向超类
-------->ModuleUsesDirective
-------->ModuleExportsDirective
-------->ModuleOpensDirective
-------->ModuleRequiresDirective
-------->ModuleProvidesDirective
~~~



Java Language Specification: https://docs.oracle.com/javase/specs/jls/se14/jls14.pdf



###符号解析

#### 如何解析类型

示例代码

~~~java
package com;


import java.util.ArrayList;
import java.util.List;

public class Calculator {
    // to get the sum of two number x, y
    int sum(int x, int y) {
        int z;
        z = x + y;

        return z;
    }

    int sum() {
        Calculator calculator;
        calculator = new Calculator();

        return calculator.sum(1, 2);
    }

    void call() {
        List<String> list = new ArrayList<>();

        list.add("xxxx");

        System.out.println(list.get(0));
    }
}
~~~



**如何解析AST的类型节点**

AST抽象语法树中的每个Type节点，声明了一个`ResolvedType resolve()`方法，用于解析类型；其本质是通过`JavaSymbolSolver.toResolvedType(Type javaparserType, Class<T> resultClass)`方法找到对应的ResolvedDesclaration；实现过程如下：

如示例代码所示，计算第13行VariableDeclarator的类型，调用`VariableDeclarator.getType()`返回AST语法树解析的Calculator类型；调用`VariableDeclarator.resolve().getType()`返回实际的变量的类型ReferenceType{com.Calculator, typeParametersMap=TypeParametersMap{nameToValue={}}}，其实现思路如下：

+ 通过调用`VariableDeclarator.resolve()`方法返回一个JavaParserVariableDeclaration对象
+ 调用JavaParserFacade.convert(Type type, Node node)
+ 调用JavaParserFacade.convert(Type type,JavaParserFactory.getContext(node, typeSolver))，获取当前上下文
+ 调用SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name)，通过上下文获取类型
  + 通过getParent()获取父类的节点，并调用parent.solveType(name)
  + 递归直到parent为null或查找到指定name的类型



**如何解析变量的类型**

如示例代码所示，变量z在第9行是一个NameExpr表达式，如何解析它的类型：即NameExpr.resolve()

~~~mermaid
sequenceDiagram
	NameExpr ->>+SymbolResolver: NameExpr.resolve()
	SymbolResolver ->>+JavaSymbolSolver: JavaSymbolSolver.resolveDeclaration(Node, ResolvedValueDeclaration.class)
	JavaSymbolSolver ->>+JavaPaserFacade: JavaPaserFacade.solve(Node)
	JavaPaserFacade ->>+SymbolSolver: SymbolSolver.solveSymbol(String, Node)
	SymbolSolver ->>+SymbolSolver: SymbolSolver.solveSymbol(String, Context)
	SymbolSolver ->>+Context: Context.solveSymbol(String Name)
	Context ->>+SymbolDeclarator: JavaParserFactory.getSymbolDeclarator(Node, TypeSolver)
	SymbolDeclarator ->>ResolvedValueDeclaration: decl.getName

~~~

如果`SymbolDeclarator.getSymbolDeclarations()`返回的`List<ResolvedValueDeclaration>`中不匹配变量z，则其会继续往上一级查找，直到找到对应的声明或者返回`SymbolReference.unsolved(ResolvedValueDeclaration.class)`



**如何解析表达式类型**

AST抽象语法树中的每个Expression节点，声明了一个`ResolvedType calculateResolvedType()`方法，用于解析表达式的类型；其本质是通过`JavaSymbolSolver.calculateType(Expression expression)`方法找到对应的resolved type

其实现过程如下：

+ 计算`x + y`表达式的类型

  如示例代码所示，计算第7行`x + y`表达式的类型，其顺序图如下：

~~~mermaid
sequenceDiagram
	Expression ->>+SymbolResolver: Expression.calculateResolvedType()
	SymbolResolver ->>+JavaParserFacade: SymbolResolver.calculateType(Expression)
	JavaParserFacade ->>+JavaParserFacade: JavaParserFacade.getTypeConcrete(Node, Boolean)
	JavaParserFacade ->>-Expression: node.accept(TypeExtractor, Boolean)
	Expression ->>+TypeExtractor: TypeExtractor.visit(BinaryExpr, Boolean)
	
	alt is PLUS
	   TypeExtractor ->>+JavaParserFacade: JavaParserFacade.getBinaryTypeConcrete(Node, Node, Boolean, Operator)	
	   JavaParserFacade ->>+JavaParserFacade: leftNodeType = getTypeConcrete(Node, Boolean)
	   JavaParserFacade ->>+JavaParserFacade: rightNodeType = getTypeConcrete(Node, Boolean)
	   
	   alt is PrimitiveInt
	   		JavaParserFacade -->-TypeExtractor: return ResolvedPrimitiveType.INT
	   end
	end
	
	
~~~







**如何解析函数的签名**

AST抽象语法树中的每个MethodCallExpr节点，声明了一个`ResolvedMethodDeclaration resolve()`方法，用于解析方法的声明；其本质是通过`JavaSymbolSolver.resolveDeclaration(Node node, Class<T> resultClass)`方法找到对应的resolved method declaration;

~~~java
ResolvedMethodDeclaration methodDeclaration = methodCallExpr.resolve()
methodDeclaration.getQualifiedSignature();
~~~

对应的类图如下：

~~~mermaid
sequenceDiagram
	MethodCallExpr ->> JavaSymbolSolver: JavaSymbolSolver.resolveDeclaration(Node, Class<T>)
	JavaSymbolSolver ->> JavaParserFacade: JavaParserFacade.solve(MethodCallExpr, boolean)
	JavaParserFacade ->> JavaParserFacade: JavaParserFacade.solveArguments(Node, NodeList<Expression>, boolean, List<ResolvedType>,List<LambdaArgumentTypePlaceholder>)
	JavaParserFacade ->> MethodCallExprContext: MethodCallExprContext.solveMethod(String, List<ResolvedType>, boolean)
	MethodCallExprContext ->> MethodCallExprContext: MethodCallExprContext.findTypeDeclarations(Optional<Expression>)
	MethodCallExprContext ->> StatementContext: StatementContext.solveType(String)
	StatementContext ->> BlockStmtContext: BlockStmtContext.solveType(String)
	BlockStmtContext ->> MethodContext: MethodContext.solveType(String)
	MethodContex ->> ClassOrInterfaceDeclarationContext: ClassOrInterfaceDeclarationContext.solveType(String)
  ClassOrInterfaceDeclarationContext ->> JavaParserTypeDeclarationAdapter: JavaParserTypeDeclarationAdapter.solveType(String)
  JavaParserTypeDeclarationAdapter ->> CompilationUnitContext: CompilationUnitContext.solve(String)
  
~~~

MethodContext.solveType(String)：通过findAll获取所有的TypeDeclaration，循环匹配是否与输入的MethodCall一样

即： wrappedNode.findAll(com.github.javaparser.ast.body.TypeDeclaration.class);



ClassOrInterfaceDeclarationContext.solveType(String): 通过wrappedNode.getImplementedTypes()和wrappedNode.getExtendedTypes()获取父类，循环匹配是否与输入的MethodCall一样；

如果未匹配，则调用JavaParserTypeDeclarationAdapter.solveType(String)查找:

+ 判断类名是否与输入的一致
+ 判断当前类的所有声明的TypeDeclaration成员是否与输入一致
+ 判断当前类的类型参数是否与输入一致
+ 判断当前类的所以父类和接口是否与输入一致，直到找到或者没有父类



CompilationUnitContext.solveType(String): 

+ 通过CompilationUnit.getTypes()获取所有的TypeDeclaration类型，循环判断是否与输入的一致
+ 通过CompilationUnit.getImports()获取所有的ImportDeclaration类型，循环判断是否与输入的一致（区分输入的是*号还是具体的类型）
+ 通过CompilationUnit.getPackageDeclaration获取当前包下的类型（包名+name），判断是否与输入的一致
+ 通过java.lang.name获取java默认的系统类型
+ 如果未找到，则返回SymbolReference.unsolved



**如何解析Lambda表达式和方法引用表达式**

使用LambdaExpr.calculateResolvedType()或MethodReferenceExpr.calculateResolvedType()解析lambda表达式和方法引用的类型，要确保lambda表达式的父节点是方法调用表达式MethodCallExpr



#### SymbolSolver

用于解析AST抽象语法树节点的符号

~~~mermaid
classDiagram
	SymbolResolver <|-- JavaSymbolSolver
	
	class SymbolResolver{
		// For a reference it would find the corresponding declaration.
		<T> T resolveDeclaration(Node node, Class<T> resultClass);
		
		// For types it would find the corresponding resolved types.
		<T> T toResolvedType(Type javaparserType, Class<T> resultClass);
		
		ResolvedType calculateType(Expression expression);
	}
~~~





#### TypeSolver

类型解析器TypeSolver：用于找到对应的类型，其主要包括以下几种Type Solver

+ ClassLoaderTypeSolver: 封装了ClassLoader类，通过反射方式加载

  ~~~java
      Class<?> clazz = classLoader.loadClass(name);
      return SymbolReference.solved(ReflectionFactory.typeDeclarationFor(clazz, getRoot()));
  ~~~

+ ReflectionTypeSolver： 用于价值java jre

+ JarTypeSolver：查找jar包中对应的类型；初始化时，通过javassist解析jar包中的.class文件

  ~~~java
      public JarTypeSolver(String pathToJar) throws IOException {
          addPathToJar(pathToJar);
      }
  
  		private void addPathToJar(String pathToJar) throws IOException {
          try {
              classPool.appendClassPath(pathToJar);
              classPool.appendSystemPath();
          } catch (NotFoundException e) {
              throw new RuntimeException(e);
          }
          JarFile jarFile = new JarFile(pathToJar);
          JarEntry entry;
          Enumeration<JarEntry> e = jarFile.entries();
          while (e.hasMoreElements()) {
              entry = e.nextElement();
              if (entry != null && !entry.isDirectory() && entry.getName().endsWith(".class")) {
                  String name = entryPathToClassName(entry.getName());
                  classpathElements.put(name, new ClasspathElement(jarFile, entry));
              }
          }
      }
  ~~~

  

+ JavaParserTypeSolver：使用javaparser解析源码，查找对应的类型

+ CombinedTypeSolver：组合type solver，包含了多种类型解析器；

  ~~~java
  public SymbolReference<ResolvedReferenceTypeDeclaration> tryToSolveType(String name) {
    // 遍历所有的类型解析器，找到对应的类型
    for (TypeSolver ts : elements) {
      SymbolReference<ResolvedReferenceTypeDeclaration> res = ts.tryToSolveType(name);
      if (res.isSolved()) {
        return res;
      }
    }
    return SymbolReference.unsolved(ResolvedReferenceTypeDeclaration.class);
  }
  ~~~

  

~~~mermaid
classDiagram
	TypeSolver <|-- ClassLoaderTypeSolver
	ClassLoaderTypeSolver <-- ReflectionTypeSolver
	TypeSolver <|-- JarTypeSolver
	TypeSolver <|-- CombinedTypeSolver
	TypeSolver <|-- JavaParserTypeSolver
	
	class TypeSolver{
		+SymbolReference<ResolvedReferenceTypeDeclaration> tryToSolveType(String name);
		+ResolvedReferenceTypeDeclaration solveType(String name);
	}
	
	class JarTypeSolver{
		Map<String, ClasspathElement> classpathElements;
		ClassPool classPool
	}
	
	class ClassLoaderTypeSolver{
		ClassLoader classLoader;
	}
	
	class JavaParserTypeSolver{
		JavaParser javaParser;
		Cache<Path, Optional<CompilationUnit>> parsedFiles;
		Cache<Path, List<CompilationUnit>> parsedDirectories;
	}
	
	class CombinedTypeSolver{
		List<TypeSolver> elements;
	}
~~~



#### ResolvedDesclaration

Resolved的声明接口类图

~~~mermaid
classDiagram
	ResolvedDeclaration <|-- ResolvedTypeDeclaration
	ResolvedTypeDeclaration <|-- ResolvedTypeParameterDeclaration
	ResolvedTypeDeclaration <|-- ResolvedReferenceTypeDeclaration
	ResolvedReferenceTypeDeclaration <|-- ResolvedInterfaceDeclaration
	ResolvedReferenceTypeDeclaration <|-- ResolvedClassDeclaration
	ResolvedReferenceTypeDeclaration <|-- ResolvedEnumDeclaration
	ResolvedReferenceTypeDeclaration <|-- ResolvedAnnotationDeclaration
	
	ResolvedDeclaration <|-- ResolvedValueDeclaration
	ResolvedValueDeclaration <|-- ResolvedEnumConstantDeclaration
	ResolvedValueDeclaration <|-- ResolvedFieldDeclaration
	ResolvedValueDeclaration <|-- ResolvedAnnotationMemberDeclaration
	ResolvedValueDeclaration <|-- ResolvedParameterDeclaration
	
	ResolvedDeclaration <|-- ResolvedMethodLikeDeclaration
	ResolvedMethodLikeDeclaration <|-- ResolvedMethodDeclaration
	ResolvedMethodLikeDeclaration <|-- ResolvedConstructorDeclaration
	
	class ResolvedTypeDeclaration {
		Set<ResolvedReferenceTypeDeclaration> internalTypes();
		ResolvedReferenceTypeDeclaration getInternalType(String name);
		boolean hasInternalType(String name);
	}
	
	class ResolvedValueDeclaration{
		ResolvedType getType();
	}
	
	class ResolvedMethodLikeDeclaration{
		ResolvedReferenceTypeDeclaration declaringType();
		ResolvedParameterDeclaration getParam(int i);
	}
	
	class ResolvedReferenceTypeDeclaration {
		List<ResolvedReferenceType> getAncestors();
		ResolvedFieldDeclaration getField(String name);
		ResolvedFieldDeclaration getVisibleField(String name);
	}
	
	class ResolvedAnnotationDeclaration{
		List<ResolvedAnnotationMemberDeclaration> getAnnotationMembers();
	}
	
	class ResolvedInterfaceDeclaration{
		List<ResolvedReferenceType> getInterfacesExtended();
	}
	
	class ResolvedClassDeclaration{
		ResolvedReferenceType getSuperClass();
		List<ResolvedReferenceType> getInterfaces();
		List<ResolvedReferenceType> getAllSuperClasses();
		List<ResolvedReferenceType> getAllInterfaces();
	}
	
	class ResolvedEnumDeclaration{
		List<ResolvedEnumConstantDeclaration> getEnumConstants();
		boolean hasEnumConstant(String name);
	}
~~~



~~~
>ResolvedDeclaration: Resolved的声明接口
---->ResolvedTypeDeclaration: Resolved的类型声明接口
-------->ResolvedTypeParameterDeclaration
-------->ResolvedReferenceTypeDeclaration
------------>ResolvedInterfaceDeclaration
------------>ResolvedClassDeclaration
------------>ResolvedEnumDeclaration
------------>ResolvedAnnotationDeclaration
---->ResolvedValueDeclaration: Resolved的值声明接口
-------->ResolvedEnumConstantDeclaration
-------->ResolvedFieldDeclaration
-------->ResolvedAnnotationMemberDeclaration
-------->ResolvedParameterDeclaration
---->ResolvedMethodLikeDeclaration: Resolved的方法声明接口
-------->ResolvedMethodDeclaration: Resolved的方法声明接口
-------->ResolvedConstructorDeclaration: Resolved的构造函数声明接口
~~~

每个Resolved的声明接口都对应三种类型：JavaParserXXX、JavassistXXX、ReflectionXXX；比如ResolvedClassDeclaration接口，其对应的子类有三种类型：JavaParserResolvedClassDeclaration、JavassistResolvedClassDeclaration、ReflectionResolvedClassDeclaration



#### Context

AST节点的上下文，其类图如下：

~~~mermaid
classDiagram
	Context <|-- AbstractJavaParserContext
	AbstractJavaParserContext <|-- BlockStmtContext
	AbstractJavaParserContext <|-- MethodCallExprContext
	AbstractJavaParserContext <|-- LambdaExprContext
	AbstractJavaParserContext <|-- AnonymousClassDeclarationContext
	AbstractJavaParserContext <|-- ForEachStatementContext
	AbstractJavaParserContext <|-- ObjectCreationContext
	AbstractJavaParserContext <|-- VariableDeclarationExprContext
	AbstractJavaParserContext <|-- ForStatementContext
	AbstractJavaParserContext <|-- StatementContext
	AbstractJavaParserContext <|-- ClassOrInterfaceDeclarationContext
	AbstractJavaParserContext <|-- TryWithResourceContext
	AbstractJavaParserContext <|-- SwitchEntryContext
	AbstractJavaParserContext <|-- VariableDeclaratorContext
	AbstractJavaParserContext <|-- CatchClauseContext
	AbstractJavaParserContext <|-- CompilationUnitContext
	AbstractJavaParserContext <|-- AbstractMethodLikeDeclarationContext
	AbstractMethodLikeDeclarationContext <|-- MethodContext
	AbstractMethodLikeDeclarationContext <|-- ConstructorContext
	AbstractJavaParserContext <|-- EnumDeclarationContext
	AbstractJavaParserContext <|-- FieldAccessContext

	class Context{
		Optional<ResolvedType> solveGenericType(String name);
		SymbolReference<ResolvedTypeDeclaration> solveType(String name);
		SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name);
		Optional<Value> solveSymbolAsValue(String name);
		SymbolReference<ResolvedConstructorDeclaration> solveConstructor(List<ResolvedType> argumentsTypes);
		SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes,
                                                                   boolean staticOnly);
    Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes);
	}
~~~

~~~
>AbstractJavaParserContext: JavaParser上下文抽象类
---->BlockStmtContext: Block语句上下文
---->MethodCallExprContext: 方法调用表达式上下文
---->LambdaExprContext: Lambda表达式上下文
---->AnonymousClassDeclarationContext: 匿名类声明上下文
---->ForEachStatementContext: For Each语句上下文
---->ObjectCreationContext: 对象创建上下文
---->VariableDeclarationExprContext: 变量声明表达式上下文
---->ForStatementContext: For语句上下文
---->StatementContext: 语句上下文
---->ClassOrInterfaceDeclarationContext: 类或接口声明上下文
---->TryWithResourceContext: try-with-resource上下文
---->SwitchEntryContext: switch case上下文
---->VariableDeclaratorContext: 变量初始化上下文
---->CatchClauseContext: catch-finnaly上下文
---->CompilationUnitContext: 编译单元上下文
---->AbstractMethodLikeDeclarationContext
-------->MethodContext: 方法上下文
-------->ConstructorContext: 构造函数上下文
---->EnumDeclarationContext: 枚举声明上下文
---->FieldAccessContext: 成员访问上下文
~~~



#### NodeWithType<N extends Node, T extends Type>

AST抽象语法树关联一个类型，其类图如下

~~~mermaid
classDiagram
	NodeWithType <|-- AnnotationMemberDeclaration
  NodeWithType <|-- CastExpr
  NodeWithType <|-- ClassExpr
  NodeWithType <|-- InstanceOfExpr
  NodeWithType <|-- MethodDeclaration
  NodeWithType <|-- ObjectCreationExpr
  NodeWithType <|-- Parameter
  NodeWithType <|-- ReceiverParameter
  NodeWithType <|-- TypeExpr
  NodeWithType <|-- VariableDeclarator
  
  class NodeWithType{
  	T getType();
  	N setType(T type);
  }
~~~

~~~
NodeWithType
--->AnnotationMemberDeclaration: XX()注解语句中的XX类型
--->CastExpr: Cast强制转换的类型
--->ClassExpr: Object.class，Object的类型
--->InstanceOfExpr: instanceof XX语句中的XX类型
--->MethodDeclaration: 方法返回值类型
--->ObjectCreationExpr: new XX()语句中XX类型
--->Parameter
--->ReceiverParameter
--->TypeExpr: XX::YY语句中的XX类型
--->VariableDeclarator: Variable的类型
~~~



#### Resolvable

Resolvable接口，包含一个resolve()方法，返回resolved类型

~~~mermaid
classDiagram
	Resolvable <|-- AnnotationDeclaration
	Resolvable <|-- AnnotationExpr
	AnnotationExpr <|-- MarkerAnnotationExpr
	AnnotationExpr <|-- NormalAnnotationExpr
	AnnotationExpr <|-- SingleMemberAnnotationExpr
	Resolvable <|-- AnnotationMemberDeclaration
	Resolvable <|-- Type
	Type <|-- VoidType
  Type <|-- PrimitiveType
  Type <|-- UnknownType
  Type <|-- IntersectionType
  Type <|-- ReferenceType
  ReferenceType <|-- ClassOrInterfaceType
  ReferenceType <|-- TypeParameter
  ReferenceType <|-- ArrayType
  Type <|-- UnionType
  Type <|-- WildcardType
  Type <|-- VarType
  Resolvable <|-- ClassOrInterfaceDeclaration
  Resolvable <|-- ConstructorDeclaration
  Resolvable <|-- EnumConstantDeclaration
  Resolvable <|-- EnumDeclaration
  Resolvable <|-- ExplicitConstructorInvocationStmt
  Resolvable <|-- FieldAccessExpr
  Resolvable <|-- FieldDeclaration
  Resolvable <|-- MethodCallExpr
  Resolvable <|-- MethodDeclaration
  Resolvable <|-- NameExpr
  Resolvable <|-- ObjectCreationExpr
  Resolvable <|-- Parameter
  Resolvable <|-- ThisExpr
  Resolvable <|-- VariableDeclarator
  
  class Resolvable{
  	T resolve();
  }
~~~

~~~
Resolvable
--->AnnotationDeclaration: resolve()方法返回一个ResolvedAnnotationDeclaration类型声明
--->AnnotationExpr: resolve()方法返回一个ResolvedAnnotationDeclaration类型声明
------>MarkerAnnotationExpr
------>NormalAnnotationExpr
------>SingleMemberAnnotationExpr
--->AnnotationMemberDeclaration: resolve()方法返回一个ResolvedAnnotationDeclaration类型声明
--->Type
------>VoidType: resolve()方法返回一个ResolvedVoidType类型声明
------>PrimitiveType: resolve()方法返回一个ResolvedPrimitiveType类型声明
------>UnknownType: resolve()方法返回一个ResolvedReferenceType类型声明
------>IntersectionType: resolve()方法返回一个ResolvedIntersectionType类型声明
------>ReferenceType
--------->ClassOrInterfaceType: resolve()方法返回一个ResolvedReferenceType类型声明
--------->TypeParameter: resolve()方法返回一个ResolvedTypeVariable类型声明
--------->ArrayType: resolve()方法返回一个ResolvedArrayType类型声明
------>UnionType: resolve()方法返回一个ResolvedUnionType类型声明
------>WildcardType: resolve()方法返回一个ResolvedWildcard类型声明
------>VarType: resolve()方法返回一个ResolvedType类型声明
--->ClassOrInterfaceDeclaration: resolve()方法返回一个ResolvedReferenceTypeDeclaration类型声明
--->ConstructorDeclaration: resolve()方法返回一个ResolvedConstructorDeclaration类型声明
--->EnumConstantDeclaration: resolve()方法返回一个ResolvedEnumConstantDeclaration类型声明
--->EnumDeclaration: resolve()方法返回一个ResolvedEnumDeclaration类型声明
--->ExplicitConstructorInvocationStmt: resolve()方法返回一个ResolvedConstructorDeclaration类型声明
--->FieldAccessExpr: resolve()方法返回一个ResolvedFieldDeclaration类型声明
--->FieldDeclaration: resolve()方法返回一个ResolvedFieldDeclaration类型声明
--->MethodCallExpr: resolve()方法返回一个ResolvedMethodDeclaration类型声明
--->MethodDeclaration: resolve()方法返回一个ResolvedMethodDeclaration类型声明
--->NameExpr: resolve()方法返回一个ResolvedValueDeclaration类型声明
--->ObjectCreationExpr: resolve()方法返回一个ResolvedConstructorDeclaration类型声明
--->Parameter: resolve()方法返回一个ResolvedParameterDeclaration类型声明
--->ThisExpr: resolve()方法返回一个ResolvedTypeDeclaration类型声明
--->VariableDeclarator: resolve()方法返回一个ResolvedValueDeclaration类型声明
~~~



#### TypeExtractor

~~~java
public class TypeExtractor extends DefaultVisitorAdapter {
    @Override
    public ResolvedType visit(VariableDeclarator node, Boolean solveLambdas) {
      //1. 父类节点是FieldDeclaration时，facade.convertToUsageVariableType(node);
      
      //2. 父类节点是VariableDeclarationExpr时，facade.convertToUsageVariableType(node);
      
      //3. 抛出异常UnsupportedOperationException
    }

    @Override
    public ResolvedType visit(Parameter node, Boolean solveLambdas) {
      //1. Parameter节点的类型是UnknownType时，抛出异常IllegalStateException
      
      //2. facade.convertToUsage(node.getType(), node);
    }

    @Override
    public ResolvedType visit(ArrayAccessExpr node, Boolean solveLambdas) {
      //获取数组访问节点（ArrayAccessExpr）的Name表达式类型
      //1. 如果表达式时数组，返回组件的类型getComponentType
      //2. 如果非数组时，则返回Name表达式类型
    }

    @Override
    public ResolvedType visit(ArrayCreationExpr node, Boolean solveLambdas) {
      //获取数组创建节点的类型，并对所有的level实例化一个ResolvedArrayType
    }

    @Override
    public ResolvedType visit(ArrayInitializerExpr node, Boolean solveLambdas) {
      //抛出UnsupportedOperationException异常
    }

    @Override
    public ResolvedType visit(AssignExpr node, Boolean solveLambdas) {
      //获取赋值语句（AssignExpr）的Target表达式（左值）的类型
    }

    @Override
    public ResolvedType visit(BinaryExpr node, Boolean solveLambdas) {
      //1.针对+, -, *, /运算，获取二元运算表达式的具体类型
      //2.针对<, <=, >, >=, =, !=, ||, &&运算，返回ResolvedPrimitiveType类型
      //3.针对&=, |=, >>=, >>>=, <<=, %=, ^=运算，返回二元运算表达式左边表达式的类型  
      //4.针对其他的运算，抛出UnsupportedOperationException异常
    }

    @Override
    public ResolvedType visit(CastExpr node, Boolean solveLambdas) {
      //facade.convertToUsage(node.getType(), JavaParserFactory.getContext(node, typeSolver));
    }

    @Override
    public ResolvedType visit(ClassExpr node, Boolean solveLambdas) {
      //Object.this: 返回Object对象的类型
    }

    @Override
    public ResolvedType visit(ConditionalExpr node, Boolean solveLambdas) {
      //获取条件表达式的Then表达式的类型
    }

    @Override
    public ResolvedType visit(EnclosedExpr node, Boolean solveLambdas) {
      //获取EnclosedExpr表达式中的Inner表达式的类型
    }

    /**
     * Java Parser can't differentiate between packages, internal types, and fields.
     * All three are lumped together into FieldAccessExpr. We need to differentiate them.
     */
    private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {
        // Fields and internal type declarations cannot have the same name.
        // Thus, these checks will always be mutually exclusive.
        if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {
            return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();
        } else if (parentType.hasField(node.getName().getId())) {
            return parentType.getField(node.getName().getId()).getType();
        } else if (parentType.hasInternalType(node.getName().getId())) {
            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);
        } else {
            throw new UnsolvedSymbolException(node.getName().getId());
        }
    }

    @Override
    public ResolvedType visit(FieldAccessExpr node, Boolean solveLambdas) {
      //1. node节点的scope为NameExpr或FieldAccessExpr表达式时
      //2. node节点的scope为ThisExpr表达式时，
      //3. node节点的scope包含"."时，
      
        // We should understand if this is a static access
        if (node.getScope() instanceof NameExpr ||
                node.getScope() instanceof FieldAccessExpr) {
            Expression staticValue = node.getScope();
            SymbolReference<ResolvedTypeDeclaration> typeAccessedStatically = JavaParserFactory.getContext(node, typeSolver).solveType(staticValue.toString());
            if (typeAccessedStatically.isSolved()) {
                // TODO here maybe we have to substitute type typeParametersValues
                return solveDotExpressionType(
                        typeAccessedStatically.getCorrespondingDeclaration().asReferenceType(), node);
            }
        } else if (node.getScope() instanceof ThisExpr) {
            // If we are accessing through a 'this' expression, first resolve the type
            // corresponding to 'this'
            SymbolReference<ResolvedTypeDeclaration> solve = facade.solve((ThisExpr) node.getScope());
            // If found get it's declaration and get the field in there
            if (solve.isSolved()) {
                ResolvedTypeDeclaration correspondingDeclaration = solve.getCorrespondingDeclaration();
                if (correspondingDeclaration instanceof ResolvedReferenceTypeDeclaration) {
                    return solveDotExpressionType(correspondingDeclaration.asReferenceType(), node);
                }
            }

        } else if (node.getScope().toString().indexOf('.') > 0) {
            // try to find fully qualified name
            SymbolReference<ResolvedReferenceTypeDeclaration> sr = typeSolver.tryToSolveType(node.getScope().toString());
            if (sr.isSolved()) {
                return solveDotExpressionType(sr.getCorrespondingDeclaration(), node);
            }
        }
        Optional<Value> value = Optional.empty();
        try {
            value = new SymbolSolver(typeSolver).solveSymbolAsValue(node.getName().getId(), node);
        } catch (com.github.javaparser.resolution.UnsolvedSymbolException use) {
            // This node may have a package name as part of its fully qualified name.
            // We should solve for the type declaration inside this package.
            SymbolReference<ResolvedReferenceTypeDeclaration> sref = typeSolver.tryToSolveType(node.toString());
            if (sref.isSolved()) {
                return new ReferenceTypeImpl(sref.getCorrespondingDeclaration(), typeSolver);
            }
        }
        if (value.isPresent()) {
            return value.get().getType();
        }
        throw new com.github.javaparser.resolution.UnsolvedSymbolException(node.getName().getId());
    }

    @Override
    public ResolvedType visit(InstanceOfExpr node, Boolean solveLambdas) {
      //返回Boolean类型
    }

    @Override
    public ResolvedType visit(StringLiteralExpr node, Boolean solveLambdas) {
      //返回String类型
    }

    @Override
    public ResolvedType visit(IntegerLiteralExpr node, Boolean solveLambdas) {
      //返回Int类型
    }

    @Override
    public ResolvedType visit(LongLiteralExpr node, Boolean solveLambdas) {
      //返回Long类型
    }

    @Override
    public ResolvedType visit(CharLiteralExpr node, Boolean solveLambdas) {
      //返回CHAR类型
    }

    @Override
    public ResolvedType visit(DoubleLiteralExpr node, Boolean solveLambdas) {
      //1. 返回Float类型
      //2. 返回Double类型
    }

    @Override
    public ResolvedType visit(BooleanLiteralExpr node, Boolean solveLambdas) {
      //返回Boolean类型
    }

    @Override
    public ResolvedType visit(NullLiteralExpr node, Boolean solveLambdas) {
      //返回Null类型
    }

    @Override
    public ResolvedType visit(MethodCallExpr node, Boolean solveLambdas) {
      //返回被调用方法的返回类型
    }

    @Override
    public ResolvedType visit(NameExpr node, Boolean solveLambdas) {
      //返回NameExpr表达式值的类型 -- node.getName().getId()
    }

    @Override
    public ResolvedType visit(ObjectCreationExpr node, Boolean solveLambdas) {
      //类实例化时，返回类的类型
    }

    @Override
    public ResolvedType visit(ThisExpr node, Boolean solveLambdas) {
      //1. 如果时Object.this表达式，则返回Object的类型
      //2. 其他的则返回this对象创建者的类型
    }

    @Override
    public ResolvedType visit(SuperExpr node, Boolean solveLambdas) {
      //返回父类的类型
    }

    @Override
    public ResolvedType visit(UnaryExpr node, Boolean solveLambdas) {
      //1. 针对"+", "-"的一元表达式，返回节点的表达式类型
      //2. 针对“!”的一元表达式，返回Boolean类型
      //3. 针对“++”, "--"一元表达式，返回节点的表达式类型
    }

    @Override
    public ResolvedType visit(VariableDeclarationExpr node, Boolean solveLambdas) {
      //返回第一个变量声明的类型
    }

    @Override
    public ResolvedType visit(LambdaExpr node, Boolean solveLambdas) {
        if (requireParentNode(node) instanceof MethodCallExpr) {
            MethodCallExpr callExpr = (MethodCallExpr) requireParentNode(node);
            int pos = JavaParserSymbolDeclaration.getParamPos(node);
            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr);
            if (!refMethod.isSolved()) {
                throw new com.github.javaparser.resolution.UnsolvedSymbolException(requireParentNode(node).toString(), callExpr.getName().getId());
            }
            Log.trace("getType on lambda expr %s", refMethod.getCorrespondingDeclaration().getName());
            if (solveLambdas) {

                // The type parameter referred here should be the java.util.stream.Stream.T
                ResolvedType result = refMethod.getCorrespondingDeclaration().getParam(pos).getType();

                if (callExpr.getScope().isPresent()) {
                    Expression scope = callExpr.getScope().get();

                    // If it is a static call we should not try to get the type of the scope
                    boolean staticCall = false;
                    if (scope instanceof NameExpr) {
                        NameExpr nameExpr = (NameExpr) scope;
                        try {
                            SymbolReference<ResolvedTypeDeclaration> type = JavaParserFactory.getContext(nameExpr, typeSolver).solveType(nameExpr.getName().getId());
                            if (type.isSolved()) {
                                staticCall = true;
                            }
                        } catch (Exception e) {

                        }
                    }

                    if (!staticCall) {
                        ResolvedType scopeType = facade.getType(scope);
                        if (scopeType.isReferenceType()) {
                            result = scopeType.asReferenceType().useThisTypeParametersOnTheGivenType(result);
                        }
                    }
                }

                // We need to replace the type variables
                Context ctx = JavaParserFactory.getContext(node, typeSolver);
                result = solveGenericTypes(result, ctx);

                //We should find out which is the functional method (e.g., apply) and replace the params of the
                //solveLambdas with it, to derive so the values. We should also consider the value returned by the
                //lambdas
                Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);
                if (functionalMethod.isPresent()) {
                    LambdaExpr lambdaExpr = node;

                    InferenceContext lambdaCtx = new InferenceContext(MyObjectProvider.INSTANCE);
                    InferenceContext funcInterfaceCtx = new InferenceContext(MyObjectProvider.INSTANCE);

                    // At this point parameterType
                    // if Function<T=? super Stream.T, ? extends map.R>
                    // we should replace Stream.T
                    ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType(), typeSolver);

                    lambdaCtx.addPair(result, functionalInterfaceType);

                    ResolvedType actualType;

                    if (lambdaExpr.getBody() instanceof ExpressionStmt) {
                        actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());
                    } else if (lambdaExpr.getBody() instanceof BlockStmt) {
                        BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();

                        // Get all the return statements in the lambda block
                        List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);

                        if (returnStmts.size() > 0) {
                            actualType = returnStmts.stream()
                                    .map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE))
                                    .filter(x -> x != null && !x.isVoid() && !x.isNull())
                                    .findFirst()
                                    .orElse(ResolvedVoidType.INSTANCE);

                        } else {
                            return ResolvedVoidType.INSTANCE;
                        }


                    } else {
                        throw new UnsupportedOperationException();
                    }

                    ResolvedType formalType = functionalMethod.get().returnType();

                    // Infer the functional interfaces' return vs actual type
                    funcInterfaceCtx.addPair(formalType, actualType);
                    // Substitute to obtain a new type
                    ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));

                    // if the functional method returns void anyway
                    // we don't need to bother inferring types
                    if (!(formalType instanceof ResolvedVoidType)) {
                        lambdaCtx.addPair(result, functionalTypeWithReturn);
                        result = lambdaCtx.resolve(lambdaCtx.addSingle(result));
                    }
                }

                return result;
            } else {
                return refMethod.getCorrespondingDeclaration().getParam(pos).getType();
            }
        } else {
            throw new UnsupportedOperationException("The type of a lambda expr depends on the position and its return value");
        }
    }

    @Override
    public ResolvedType visit(MethodReferenceExpr node, Boolean solveLambdas) {
        if (requireParentNode(node) instanceof MethodCallExpr) {
            MethodCallExpr callExpr = (MethodCallExpr) requireParentNode(node);
            int pos = JavaParserSymbolDeclaration.getParamPos(node);
            SymbolReference<ResolvedMethodDeclaration> refMethod = facade.solve(callExpr, false);
            if (!refMethod.isSolved()) {
                throw new com.github.javaparser.resolution.UnsolvedSymbolException(requireParentNode(node).toString(), callExpr.getName().getId());
            }
            Log.trace("getType on method reference expr %s", refMethod.getCorrespondingDeclaration().getName());
            if (solveLambdas) {
                MethodUsage usage = facade.solveMethodAsUsage(callExpr);
                ResolvedType result = usage.getParamType(pos);
                // We need to replace the type variables
                Context ctx = JavaParserFactory.getContext(node, typeSolver);
                result = solveGenericTypes(result, ctx);

                //We should find out which is the functional method (e.g., apply) and replace the params of the
                //solveLambdas with it, to derive so the values. We should also consider the value returned by the
                //lambdas
                if (FunctionalInterfaceLogic.getFunctionalMethod(result).isPresent()) {
                    MethodReferenceExpr methodReferenceExpr = node;

                    ResolvedType actualType = facade.toMethodUsage(methodReferenceExpr).returnType();
                    ResolvedType formalType = FunctionalInterfaceLogic.getFunctionalMethod(result).get().returnType();

                    InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);
                    inferenceContext.addPair(formalType, actualType);
                    result = inferenceContext.resolve(inferenceContext.addSingle(result));
                }

                return result;
            }
            return refMethod.getCorrespondingDeclaration().getParam(pos).getType();
        }
        throw new UnsupportedOperationException("The type of a method reference expr depends on the position and its return value");
    }

    @Override
    public ResolvedType visit(FieldDeclaration node, Boolean solveLambdas) {
      //1. 返回成员变量声明的类型
    }
}
~~~

